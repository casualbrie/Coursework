"""
Sports Analytics
"""

import numeric
import codeskulptor
from urllib import request
import comp140_module6 as sports
import math

def mse(result, expected):
    """
    Calculate the mean squared error between two data sets.

    The length of the inputs, result and expected, must be the same.

    inputs:
        - result: a list of integers or floats representing the actual output
        - expected: a list of integers or floats representing the predicted output

    returns: a float that is the mean squared error between the two data sets
    """
    combo = zip(result, expected)
    error = 0
    for actual, predicted in combo:
        error += ((actual - predicted) ** 2) / len(result)
    return error

def read_matrix(filename):
    """
    Parse data from the file with the given filename into a matrix.

    input:
        - filename: a string representing the name of the file

    returns: a matrix containing the elements in the given file
    """
    data_list = []
    url = codeskulptor.file2url(filename)
    netfile = request.urlopen(url)
    
    for line in netfile.readlines():
        data_num = []
        strline = line.decode('utf-8')
        #removing the endline character
        strline = strline[:-1]
        data = strline.split(', ')
        #converting the data to floats
        for num in data:
            data_num.append(float(num))
        data_list.append(data_num)
    return numeric.Matrix(data_list)
#print(read_matrix("comp140_analytics_simple_matrix.txt"))
#print(read_matrix('comp140_analytics_test_matrix1.txt'))


class LinearModel:
    """
    A class used to represent a Linear statistical
    model of multiple variables. This model takes
    a vector of input variables and predicts that
    the measured variable will be their weighted sum.
    """

    def __init__(self, weights):
        """
        Create a new LinearModel.

        inputs:
            - weights: an m x 1 matrix of weights
        """
        self._weights = weights

    def __str__(self):
        """
        Return: weights as a human readable string.
        """
        return str(self._weights)

    def get_weights(self):
        """
        Return: the weights associated with the model.
        """
        return self._weights

    def generate_predictions(self, inputs):
        """
        Use this model to predict a matrix of
        measured variables given a matrix of input data.

        inputs:
            - inputs: an n x m matrix of explanatory variables

        Returns: an n x 1 matrix of predictions
        """
        return inputs @ self._weights

    def prediction_error(self, inputs, actual_result):
        """
        Calculate the MSE between the actual measured
        data and the predictions generated by this model
        based on the input data.

        inputs:
            - inputs: inputs: an n x m matrix of explanatory variables
            - actual_result: an n x 1 matrix of the corresponding
                             actual values for the measured variables

        Returns: a float that is the MSE between the generated
        data and the actual data
        """
        actual_list = []
        gen_list = []
        matrix_len = actual_result.shape()
        generated = self.generate_predictions(inputs)
        #iterating through the matrix to be able to use mse
        for idx in range(matrix_len[0]):
            actual_list.append(actual_result[(idx, 0)])
            gen_list.append(generated[(idx, 0)])
        return mse(actual_list, gen_list)

#obj = LinearModel(numeric.Matrix([[1.0],
#                                  [5.0],
#                                  [3.0]])) 
#obj.generate_predictions(numeric.Matrix([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]))
    
    
def fit_least_squares(input_data, output_data):
    """
    Create a Linear Model which predicts the output vector
    given the input matrix with minimal Mean-Squared Error.

    inputs:
        - input_data: an n x m matrix
        - output_data: an n x 1 matrix

    returns: a LinearModel object which has been fit to approximately
    match the data
    """
    new_weights = (input_data.transpose()@input_data).inverse()@input_data.transpose() @ output_data
    return LinearModel(new_weights)

def soft_threshold(point, move):
    """
    Moves point closer to 0 by the distance move. 
    If this would move point past 0, the value is simply 0.
    
    inputs:
        - point: the point to be changed
        - move: the distance to shift point
        
    returns: the moved point
    """
    if point > move:
        return point - move
    if point < -(move):
        return point + move
    return 0

def fit_lasso(param, iterations, input_data, output_data):
    """
    Create a Linear Model which predicts the output vector
    given the input matrix using the LASSO method.

    inputs:
        - param: a float representing the lambda parameter
        - iterations: an integer representing the number of iterations
        - input_data: an n x m matrix
        - output_data: an n x 1 matrix

    returns: a LinearModel object which has been fit to approximately
    match the data
    """
    rows_cols = input_data.shape()
    least = fit_least_squares(input_data, output_data).get_weights()
    counter = 0
    
    #calculating the unchanged matrix multiplications outside of the while loop
    inp_out = input_data.transpose() @ output_data
    inp_inp = input_data.transpose() @ input_data
    
    while counter < iterations:
        least_old = least.copy()
        one_norm = 0
        for idx in range(rows_cols[1]):
            soft1 = ((inp_out[(idx, 0)] - (inp_inp.getrow(idx) @ least)[(0, 0)]) / 
                     inp_inp[(idx, idx)])
            
            soft2 = param / (2 * inp_inp[(idx, idx)])
            least[(idx, 0)] = soft_threshold(least[(idx, 0)] + soft1, soft2)
            
            #calculating the one norm in the same loop to cut down on time
            one_norm = one_norm + math.fabs(least[(idx, 0)] - least_old[(idx, 0)])
        
        if one_norm < (10**-5):
            break
        counter = counter + 1
    return LinearModel(least)


def run_experiment(iterations):
    """
    Using some historical data from 1954-2000, as
    training data, generate weights for a Linear Model
    using both the Least-Squares method and the
    LASSO method (with several different lambda values).

    Test each of these models using the historical
    data from 2001-2012 as test data.

    inputs:
        - iterations: an integer representing the number of iterations to use

    Print out the model's prediction error on the two data sets
    """
    stats1 = read_matrix("comp140_analytics_baseball.txt")
    wins1 = read_matrix("comp140_analytics_wins.txt")
    print("1954-2000 data error:")
    print("Least squares: " + str(fit_least_squares(stats1, wins1).prediction_error(stats1, wins1)))
    print("LASSO, lambda = 5000: " + str(fit_lasso(5000, iterations, stats1, wins1).prediction_error(stats1, wins1)))
    print("LASSO, lambda = 10000: " + str(fit_lasso(10000, iterations, stats1, wins1).prediction_error(stats1, wins1)))
    print("LASSO, lambda = 30000: " + str(fit_lasso(30000, iterations, stats1, wins1).prediction_error(stats1, wins1)))
    
    stats2 = read_matrix("comp140_analytics_baseball_test.txt")
    wins2 = read_matrix("comp140_analytics_wins_test.txt")
    print("\n2001-2012 data error using model of 1954-2000:")
    print("Least squares: " + str(fit_least_squares(stats1, wins1).prediction_error(stats2, wins2)))
    print("LASSO, lambda = 5000: " + str(fit_lasso(5000, iterations, stats1, wins1).prediction_error(stats2, wins2)))
    print("LASSO, lambda = 5000: " + str(fit_lasso(10000, iterations, stats1, wins1).prediction_error(stats2, wins2)))
    print("LASSO, lambda = 5000: " + str(fit_lasso(30000, iterations, stats1, wins1).prediction_error(stats2, wins2)))

run_experiment(500)
